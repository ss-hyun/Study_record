---
title: "소소한 팁 모음"
date: 2021-06-17T12:46:38+09:00
draft: false
---

# C++
## endl 수행 시간
---
solution 이후 이를 출력해줄 때, 다음과 같은 두 가지의 방법을 사용할 수 있다. 
```c++
std:: cout << solution() << endl;
std:: cout << solution() << '\n';
```
이때 두 문장은 solution 출력 후 개행이라는 같은 결과를 보여주지만, 약간은 다른 작업을 수행한다.

endl의 경우 단순히 개행 문자를 출력하는게 아니라 실행마다 출력 버퍼를 비워주는 flush() 함수를 실행시킨다. 따라서 단순히 개행 문자를 출력하는 것 보다 수행에 많은 시간이 걸리게 된다.

이런 이유로 백준과 같은 사이트에서 알고리즘 문제 풀이를 할 때에 endl을 사용하는 것은 수행 시간 초과를 유발할 수 있으므로, endl 대신 개행 문자를 바로 출력하는 코드를 작성하는 습관을 들이는 것이 좋겠다.

## map과 unordered_map의 시간 복잡도
---
두 자료구조 모두 key 값과 value 값의 쌍들을 key의 중복을 허용하지 않고 저장하는 자료구조이다. 하지만 map은 key를 기준으로 오름차순 자동정렬을 하여 저장하고, unordered_map은 정렬 없이 순서대로 저장하기 때문에 두 자료구조를 어떻게 사용하는 지에 따라 다른 성능을 보여준다.

map은 레드-블랙 트리 기반으로, 검색/삽입/삭제 모두 O(log n)으로 수행된다. 이에 비해 unordered_map은 해시 함수(hash function)를 이용하기 때문에 해시 충돌이 일어나지 않는다면 검색/삽입/삭제가 모두 O(1)으로 수행되게 된다. 이는 해시 값 계산에 상수 시간이 걸리기 때문인데, 극단적으로 해시 충돌이 많이 일어날 경우 삽입 및 탐색 시 일반 map보다 높은 O(n)의 시간 복잡도를 가질 수 있다. 일반 map은 평균도 최악도 log n이기 때문에 unordered_map보다 더 안정적으로 사용할 수 있다.

unordered_map 라이브러리 에는 기본 타입 및 string에 대한 해시함수가 내장되어 있어 편리하게 사용 가능하다. 하지만 내가 만든 클래스를 key 값으로 사용하기 위해서는 해시함수를 직접 만들어주어야 하기 때문에 사용이 쉽지 않다.

unordered_map은 key 값과 해시 함수로 얻어낸 값을 index로 가지는 배열에 linked list로 요소들을 연결해 구성하는 해시맵(hashmap)으로 이루어져 있다. 배열의 크기를 처음부터 크게 설정하면 메모리의 낭비가 심하므로 삽입되는 요소가 많아지면 배열의 크기를 점진적으로 키우는 방법을 택한다. 이때 배열의 크기가 조정되면 해시 함수 또한 변경되어야 하는데, 해시 함수가 변경되면 map에 존재하던 모든 요소들을 다시 삽입하는 시간복잡도 N의 rehash를 진행해야 한다.