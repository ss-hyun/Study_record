---
title: "알고리즘 문제풀이 코드작성 팁"
---

# 목차
* [시간 단축 팁](#보면-좋을-시간-단축-팁)

* [C++](#c)  
    - [map과 unordered_map의 시간 복잡도](#map과-unordered_map의-시간-복잡도)  
    - [Fast IO (c++17)](#fast-io-c17)  
        - [endl 수행 시간](#endl-수행-시간)  
        - [C/C++ 입출력 버퍼 동기화 해제](#cc-입출력-버퍼-동기화-해제)
        - [참고 링크](#참고-링크)
    - [간이 테스터 만들기 (반례찾기)](#간이-테스터-만들기-반례찾기)

<br><br>

# 보면 좋을 시간 단축 팁
https://dining-developer.tistory.com/39  
* Function call 최소화
* Inline keyword를 맹신하지 말 것
* Register keyword 사용 하기
* Loop optimization
* Looop unrolling

https://dining-developer.tistory.com/41
* Cache를 고려하자
* 낮은 N에서는 N^2이 N*lolg(N)보다 빠를 수도 있다.
* 값 복사 최소화

<br>

# C++
## map과 unordered_map의 시간 복잡도
---
두 자료구조 모두 key 값과 value 값의 쌍들을 key의 중복을 허용하지 않고 저장하는 자료구조이다. 하지만 map은 key를 기준으로 오름차순 자동정렬을 하여 저장하고, unordered_map은 정렬 없이 순서대로 저장하기 때문에 두 자료구조를 어떻게 사용하는 지에 따라 다른 성능을 보여준다.

map은 레드-블랙 트리 기반으로, 검색/삽입/삭제 모두 O(log n)으로 수행된다. 이에 비해 unordered_map은 해시 함수(hash function)를 이용하기 때문에 해시 충돌이 일어나지 않는다면 검색/삽입/삭제가 모두 O(1)으로 수행되게 된다. 이는 해시 값 계산에 상수 시간이 걸리기 때문인데, 극단적으로 해시 충돌이 많이 일어날 경우 삽입 및 탐색 시 일반 map보다 높은 O(n)의 시간 복잡도를 가질 수 있다. 일반 map은 평균도 최악도 log n이기 때문에 unordered_map보다 더 안정적으로 사용할 수 있다.

unordered_map 라이브러리 에는 기본 타입 및 string에 대한 해시함수가 내장되어 있어 편리하게 사용 가능하다. 하지만 내가 만든 클래스를 key 값으로 사용하기 위해서는 해시함수를 직접 만들어주어야 하기 때문에 사용이 쉽지 않다.

unordered_map은 key 값과 해시 함수로 얻어낸 값을 index로 가지는 배열에 linked list로 요소들을 연결해 구성하는 해시맵(hashmap)으로 이루어져 있다. 배열의 크기를 처음부터 크게 설정하면 메모리의 낭비가 심하므로 삽입되는 요소가 많아지면 배열의 크기를 점진적으로 키우는 방법을 택한다. 이때 배열의 크기가 조정되면 해시 함수 또한 변경되어야 하는데, 해시 함수가 변경되면 map에 존재하던 모든 요소들을 다시 삽입하는 시간복잡도 N의 rehash를 진행해야 한다.

<br>

## Fast IO (c++17)
---
알고리즘 문제를 풀이할 때 가장 중요한 건 올바른 알고리즘을 사용하여 문제를 풀어내는 것이다. 하지만 문제를 풀다보면 올바른 알고리즘을 사용했음에도 불구하고 시간 초과를 맞닥뜨리게 되는 경우가 있는데, 입출력 량이 많은 문제일 때(일반적으로 10만 이상) 대부분 입출력 최적화를 통해 해결되곤 한다. 입출력 연산은 프로그램의 실행 시간 중 상당량을 차지하기 때문에, 입출력 량이 많은 문제에서 이를 최적화 해주는 것은 실행시간에서 상당한 이득을 가져온다. 시간초과가 나지는 않더라도 많은 경우 프로그램의 실행시간을 단축하는 것은 유용하기 때문에 알고리즘 대회 혹은 코딩테스트 등을 준비하는 사람들이라면 이에 관한 내용을 알아 놓는 것이 좋다. 아직은 Fast IO 코드를 직접 작성할 정도로 이해가 깊지는 않지만, 여러 지식인 분들의 글을 참고하여 이해한 내용을 정리해보았다.

<br>

### **endl 수행 시간**
c++ 유저라면 입출력으로 cin과 cout를 사용하는 것이 익숙하고, 코드 작성의 편의성과 가독성을 생각하여 endl을 사용해 개행을 해온 사람들이 있을 것이다. 하지만 알고리즘 문제 풀이를 할 때 endl을 사용하는 것은 최대한 지양해야하는 일이다.

이는 endl이 단순히 개행만을 해주는 것이 아니라 실행 마다 flush로 출력 버퍼를 비워주는 작업을 하여 실행 시간에 영향을 주기 때문인데, 이에 대하여 이해하기 위해서는 버퍼가 무엇이고 어떤 역할을 하는지에 대하여 알아야 한다.

버퍼(Buffer)란 임시 메모리 공간으로 표준 입출력을 사용하는 프로그램에서는 표준 스트림에서 데이터를 읽어오거나 표준 스트림으로 데이터를 출력할 때 입력버퍼와 출력버퍼라는 임시 메모리 공간을 할당하여 사용한다. 입출력 버퍼를 이용하면 데이터들을 입출력이 발생하는 즉시 처리하지 않고 일정량 이상의 데이터를 버퍼에 임시로 저장해놓았다가 한 번에 처리할 수 있기 때문에, 다양한 입출력 상황에서의 안정성을 높이고 스트림에 접근하는 횟수를 줄여 속도를 향상시킬 수 있다. 이때 출력 버퍼에 기록된 내용을 실제로 출력해주어 버퍼를 비우는 것을 flush 한다고 한다.

endl은 출력이 꼭 필요하지 않은 상황에서도 개행 후에 flush를 필수적으로 해주는데, 스트림으로 데이터를 내보내는 작업은 많은 비용을 소모하기 때문에 출력량이 많을 때 endl을 반복적으로 수행하게 되면 프로그램의 속도가 크게 저하되어 '\n'을 사용하는 것에 비해 수행에 많은 시간이 걸리게 된다. 따라서 백준과 같은 사이트에서 알고리즘 문제 풀이를 할 때에 endl을 사용하는 것은 수행 시간 초과를 유발할 수 있으므로, flush가 꼭 필요한 상황이 아니라면 endl 대신 개행 문자를 바로 출력하는 코드를 작성하는 습관을 들이는 것이 좋다.

<br>

### **C/C++ 입출력 버퍼 동기화 해제**
```ios_base::sync_with_stdio``` 구문은 c의 stdio와 cpp의 iostream

<br>

### **참고 링크**
[표준 스트림, 표준 입출력에 대해 알아보자](https://shoark7.github.io/programming/knowledge/what-is-standard-stream "바로가기")  
[Fast I/O 구현 코드](https://www.acmicpc.net/blog/view/105 "바로가기")

<br>

## 간이 테스터 만들기 (반례찾기)
---
http://www.secmem.org/blog/2021/06/20/tester/
http://www.secmem.org/blog/2021/02/19/wa/
